
- Every async function is called a coroutine, and they have the property of being flexible, receiving suspensions and resumes from the event loop management in order the code to be executed concurrently

- The 'await' syntax is used within coroutines to 'await' the execution of an asynchronous operation

- Coroutines can await other coroutines or asynchronous operations (it depends on the logic being applied)

- And they can also be awaited concurrently/simultaneously with the help of asyncio.gather (which is managed by the event loop)

- The asyncio.run function is a convenient way to run a coroutine and manage the event loop lifecycle. We normally apply it to our main coroutine (which can call others or not, but usually it does)
    - This function creates a new event loop, runs the provided coroutine, and automatically handles the cleanup of resources and event loop closing

- For more control it is possible to create event loops manually using asyncio.new_event_loop and running them with asyncio.run_until_complete. This approach does exists, but is way more complicated.

- Tasks are the primary building blocks for executing and managing asynchronous operations in AsyncIO. Understanging then how to create, schedule and manage tasks is crucial for developing efficient and scalable asynchronous applications

- The asyncio.create_task function creates a Task object from the provided corroutine. The main coroutine awaits the completion of the Task, allowing the event loop to run the coroutine concurrently.

- As we already have seen, the asyncio.gather function can be used to schedule and await multiple Tasks concurrently. The event loop manages the concurrent execution of all the tasks gathered.

- AsyncIO supports the work/connection with various databases through asynchronous database drivers. Popular asynchronous drivers include:
    - AsyncPG (for PostgreSQL)
    - Motor (for MongoDB)
    - Aio_pika (for RabbitMQ)
    - Asyncio Redis (for Redis)
    - aiosqlite (for sqlite)
    - aioodbc (for SQL Server)
